(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "./node_modules/_mini-css-extract-plugin@0.7.0@mini-css-extract-plugin/dist/loader.js!./node_modules/_css-loader@0.28.11@css-loader/index.js!./node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/stylePostLoader.js!./node_modules/_vue-loader@15.7.1@vue-loader/lib/index.js?!./src/components/bdMaps/map.vue?vue&type=style&index=0&id=0d26af56&scoped=true&lang=css&":
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/_mini-css-extract-plugin@0.7.0@mini-css-extract-plugin/dist/loader.js!./node_modules/_css-loader@0.28.11@css-loader!./node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/stylePostLoader.js!./node_modules/_vue-loader@15.7.1@vue-loader/lib??vue-loader-options!./src/components/bdMaps/map.vue?vue&type=style&index=0&id=0d26af56&scoped=true&lang=css& ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/components/bdMaps/map.vue?./node_modules/_mini-css-extract-plugin@0.7.0@mini-css-extract-plugin/dist/loader.js!./node_modules/_css-loader@0.28.11@css-loader!./node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/stylePostLoader.js!./node_modules/_vue-loader@15.7.1@vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/_vue-loader@15.7.1@vue-loader/lib/index.js?!./src/components/bdMaps/map.vue?vue&type=script&lang=js&":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/_vue-loader@15.7.1@vue-loader/lib??vue-loader-options!./src/components/bdMaps/map.vue?vue&type=script&lang=js& ***!
  \*************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vuex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vuex */ \"./node_modules/_vuex@3.1.1@vuex/dist/vuex.esm.js\");\n/* harmony import */ var _unit_layer_Polygon_Draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../..//unit/layer/Polygon.Draw */ \"./src/unit/layer/Polygon.Draw.js\");\n/* harmony import */ var _unit_layer_Polygon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../..//unit/layer/Polygon */ \"./src/unit/layer/Polygon.js\");\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    mixins: [_unit_layer_Polygon_Draw__WEBPACK_IMPORTED_MODULE_1__[\"default\"]],\n   data () {\n       return {\n           asdasd: 465\n       }\n   },\n    mounted () {\n        this.initMap1();\n        // this.initMap2()\n    },\n    methods: {\n        ...Object(vuex__WEBPACK_IMPORTED_MODULE_0__[\"mapMutations\"])(['setBdMap1', 'setBdMap2']),\n       initMap1 () {\n           // 百度地图API功能\n           this.setBdMap1(new BMap.Map(\"bdMap_1\"));    // 创建Map实例\n           this.map.centerAndZoom(new BMap.Point(116.404, 39.915), 11);  // 初始化地图,设置中心点坐标和地图级别\n           //添加地图类型控件\n           this.map.addControl(new BMap.MapTypeControl({\n               mapTypes:[\n                   BMAP_NORMAL_MAP,\n                   BMAP_HYBRID_MAP\n               ]}));\n           this.map.setCurrentCity(\"北京\");          // 设置地图显示的城市 此项是必须设置的\n           this.map.enableScrollWheelZoom(true);\n       },\n        initMap2 () {\n            // 百度地图API功能\n            this.setBdMap2(new BMap.Map(\"bdMap_2\"));    // 创建Map实例\n            this.map2.centerAndZoom(new BMap.Point(116.404, 39.915), 11);  // 初始化地图,设置中心点坐标和地图级别\n            //添加地图类型控件\n            // this.map1.addControl(new BMap.MapTypeControl({\n            //     mapTypes:[\n            //         BMAP_NORMAL_MAP,\n            //         BMAP_HYBRID_MAP\n            //     ]}));\n            this.map2.setCurrentCity(\"承德\");          // 设置地图显示的城市 此项是必须设置的\n            this.map2.enableScrollWheelZoom(true);\n            var randomCount = 300;\n\n            var data = [];\n\n            var citys = [\"北京\", \"天津\", \"上海\", \"重庆\", \"石家庄\", \"太原\", \"呼和浩特\", \"哈尔滨\", \"长春\", \"沈阳\"];\n\n            // 构造数据\n            while (randomCount--) {\n                var cityCenter = mapv.utilCityCenter.getCenterByCityName(citys[parseInt(Math.random() * citys.length)]);\n                data.push({\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [cityCenter.lng - 2 + Math.random() * 4, cityCenter.lat - 2 + Math.random() * 4]\n                    },\n                    count: 30 * Math.random()\n                });\n            }\n\n            var dataSet = new mapv.DataSet(data);\n\n            var options = {\n                fillStyle: 'rgba(55, 50, 250, 0.8)',\n                shadowColor: 'rgba(255, 250, 50, 1)',\n                shadowBlur: 20,\n                max: 100,\n                size: 50,\n                label: {\n                    show: true,\n                    fillStyle: 'white',\n                    // shadowColor: 'yellow',\n                    // font: '20px Arial',\n                    // shadowBlur: 10,\n                },\n                globalAlpha: 0.5,\n                gradient: { 0.25: \"rgb(0,0,255)\", 0.55: \"rgb(0,255,0)\", 0.85: \"yellow\", 1.0: \"rgb(255,0,0)\"},\n                draw: 'honeycomb'\n            }\n\n            var mapvLayer = new mapv.baiduMapLayer( this.map2, dataSet, options);\n        }\n    },\n    computed: {\n        ...Object(vuex__WEBPACK_IMPORTED_MODULE_0__[\"mapState\"])({\n            map: state => state.bdMap.map1,\n            map2: state => state.bdMap.map2\n        })\n    }\n});\n\n\n//# sourceURL=webpack:///./src/components/bdMaps/map.vue?./node_modules/_vue-loader@15.7.1@vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/templateLoader.js?!./node_modules/_vue-loader@15.7.1@vue-loader/lib/index.js?!./src/components/bdMaps/map.vue?vue&type=template&id=0d26af56&scoped=true&":
/*!******************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/_vue-loader@15.7.1@vue-loader/lib??vue-loader-options!./src/components/bdMaps/map.vue?vue&type=template&id=0d26af56&scoped=true& ***!
  \******************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", { attrs: { id: \"bdMap\" } }, [\n    _c(\"div\", { attrs: { id: \"bdMap_1\" } }),\n    _vm._v(\" \"),\n    _c(\"div\", { staticClass: \"toolBox\" }, [\n      _c(\"button\", { staticClass: \"toolBtn\", on: { click: _vm.enableDraw } }, [\n        _c(\"svg\", { staticClass: \"icon\", attrs: { \"aria-hidden\": \"true\" } }, [\n          _c(\"use\", { attrs: { \"xlink:href\": \"#lyt-icon-huaduobianxing\" } })\n        ])\n      ])\n    ])\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n\n//# sourceURL=webpack:///./src/components/bdMaps/map.vue?./node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/_vue-loader@15.7.1@vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/_vue-style-loader@4.1.2@vue-style-loader/index.js!./node_modules/_mini-css-extract-plugin@0.7.0@mini-css-extract-plugin/dist/loader.js!./node_modules/_css-loader@0.28.11@css-loader/index.js!./node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/stylePostLoader.js!./node_modules/_vue-loader@15.7.1@vue-loader/lib/index.js?!./src/components/bdMaps/map.vue?vue&type=style&index=0&id=0d26af56&scoped=true&lang=css&":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/_vue-style-loader@4.1.2@vue-style-loader!./node_modules/_mini-css-extract-plugin@0.7.0@mini-css-extract-plugin/dist/loader.js!./node_modules/_css-loader@0.28.11@css-loader!./node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/stylePostLoader.js!./node_modules/_vue-loader@15.7.1@vue-loader/lib??vue-loader-options!./src/components/bdMaps/map.vue?vue&type=style&index=0&id=0d26af56&scoped=true&lang=css& ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(/*! !../../../node_modules/_mini-css-extract-plugin@0.7.0@mini-css-extract-plugin/dist/loader.js!../../../node_modules/_css-loader@0.28.11@css-loader!../../../node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/_vue-loader@15.7.1@vue-loader/lib??vue-loader-options!./map.vue?vue&type=style&index=0&id=0d26af56&scoped=true&lang=css& */ \"./node_modules/_mini-css-extract-plugin@0.7.0@mini-css-extract-plugin/dist/loader.js!./node_modules/_css-loader@0.28.11@css-loader/index.js!./node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/stylePostLoader.js!./node_modules/_vue-loader@15.7.1@vue-loader/lib/index.js?!./src/components/bdMaps/map.vue?vue&type=style&index=0&id=0d26af56&scoped=true&lang=css&\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(/*! ../../../node_modules/_vue-style-loader@4.1.2@vue-style-loader/lib/addStylesClient.js */ \"./node_modules/_vue-style-loader@4.1.2@vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"7c04cc9d\", content, false, {});\n// Hot Module Replacement\nif(true) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(/*! !../../../node_modules/_mini-css-extract-plugin@0.7.0@mini-css-extract-plugin/dist/loader.js!../../../node_modules/_css-loader@0.28.11@css-loader!../../../node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/_vue-loader@15.7.1@vue-loader/lib??vue-loader-options!./map.vue?vue&type=style&index=0&id=0d26af56&scoped=true&lang=css& */ \"./node_modules/_mini-css-extract-plugin@0.7.0@mini-css-extract-plugin/dist/loader.js!./node_modules/_css-loader@0.28.11@css-loader/index.js!./node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/stylePostLoader.js!./node_modules/_vue-loader@15.7.1@vue-loader/lib/index.js?!./src/components/bdMaps/map.vue?vue&type=style&index=0&id=0d26af56&scoped=true&lang=css&\", function() {\n     var newContent = __webpack_require__(/*! !../../../node_modules/_mini-css-extract-plugin@0.7.0@mini-css-extract-plugin/dist/loader.js!../../../node_modules/_css-loader@0.28.11@css-loader!../../../node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/_vue-loader@15.7.1@vue-loader/lib??vue-loader-options!./map.vue?vue&type=style&index=0&id=0d26af56&scoped=true&lang=css& */ \"./node_modules/_mini-css-extract-plugin@0.7.0@mini-css-extract-plugin/dist/loader.js!./node_modules/_css-loader@0.28.11@css-loader/index.js!./node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/stylePostLoader.js!./node_modules/_vue-loader@15.7.1@vue-loader/lib/index.js?!./src/components/bdMaps/map.vue?vue&type=style&index=0&id=0d26af56&scoped=true&lang=css&\");\n     if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}\n\n//# sourceURL=webpack:///./src/components/bdMaps/map.vue?./node_modules/_vue-style-loader@4.1.2@vue-style-loader!./node_modules/_mini-css-extract-plugin@0.7.0@mini-css-extract-plugin/dist/loader.js!./node_modules/_css-loader@0.28.11@css-loader!./node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/stylePostLoader.js!./node_modules/_vue-loader@15.7.1@vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./src/components/bdMaps/map.vue":
/*!***************************************!*\
  !*** ./src/components/bdMaps/map.vue ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _map_vue_vue_type_template_id_0d26af56_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map.vue?vue&type=template&id=0d26af56&scoped=true& */ \"./src/components/bdMaps/map.vue?vue&type=template&id=0d26af56&scoped=true&\");\n/* harmony import */ var _map_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map.vue?vue&type=script&lang=js& */ \"./src/components/bdMaps/map.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport *//* harmony import */ var _map_vue_vue_type_style_index_0_id_0d26af56_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map.vue?vue&type=style&index=0&id=0d26af56&scoped=true&lang=css& */ \"./src/components/bdMaps/map.vue?vue&type=style&index=0&id=0d26af56&scoped=true&lang=css&\");\n/* harmony import */ var _node_modules_vue_loader_15_7_1_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../node_modules/_vue-loader@15.7.1@vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/_vue-loader@15.7.1@vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_15_7_1_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n  _map_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _map_vue_vue_type_template_id_0d26af56_scoped_true___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _map_vue_vue_type_template_id_0d26af56_scoped_true___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  \"0d26af56\",\n  null\n  \n)\n\n/* hot reload */\nif (true) {\n  var api = __webpack_require__(/*! ./node_modules/_vue-hot-reload-api@2.3.3@vue-hot-reload-api/dist/index.js */ \"./node_modules/_vue-hot-reload-api@2.3.3@vue-hot-reload-api/dist/index.js\")\n  api.install(__webpack_require__(/*! vue */ \"./node_modules/_vue@2.6.10@vue/dist/vue.esm.js\"))\n  if (api.compatible) {\n    module.hot.accept()\n    if (!api.isRecorded('0d26af56')) {\n      api.createRecord('0d26af56', component.options)\n    } else {\n      api.reload('0d26af56', component.options)\n    }\n    module.hot.accept(/*! ./map.vue?vue&type=template&id=0d26af56&scoped=true& */ \"./src/components/bdMaps/map.vue?vue&type=template&id=0d26af56&scoped=true&\", function(__WEBPACK_OUTDATED_DEPENDENCIES__) { /* harmony import */ _map_vue_vue_type_template_id_0d26af56_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map.vue?vue&type=template&id=0d26af56&scoped=true& */ \"./src/components/bdMaps/map.vue?vue&type=template&id=0d26af56&scoped=true&\");\n(function () {\n      api.rerender('0d26af56', {\n        render: _map_vue_vue_type_template_id_0d26af56_scoped_true___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n        staticRenderFns: _map_vue_vue_type_template_id_0d26af56_scoped_true___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]\n      })\n    })(__WEBPACK_OUTDATED_DEPENDENCIES__); }.bind(this))\n  }\n}\ncomponent.options.__file = \"src/components/bdMaps/map.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);\n\n//# sourceURL=webpack:///./src/components/bdMaps/map.vue?");

/***/ }),

/***/ "./src/components/bdMaps/map.vue?vue&type=script&lang=js&":
/*!****************************************************************!*\
  !*** ./src/components/bdMaps/map.vue?vue&type=script&lang=js& ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_15_7_1_vue_loader_lib_index_js_vue_loader_options_map_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/_vue-loader@15.7.1@vue-loader/lib??vue-loader-options!./map.vue?vue&type=script&lang=js& */ \"./node_modules/_vue-loader@15.7.1@vue-loader/lib/index.js?!./src/components/bdMaps/map.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_vue_loader_15_7_1_vue_loader_lib_index_js_vue_loader_options_map_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack:///./src/components/bdMaps/map.vue?");

/***/ }),

/***/ "./src/components/bdMaps/map.vue?vue&type=style&index=0&id=0d26af56&scoped=true&lang=css&":
/*!************************************************************************************************!*\
  !*** ./src/components/bdMaps/map.vue?vue&type=style&index=0&id=0d26af56&scoped=true&lang=css& ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_style_loader_4_1_2_vue_style_loader_index_js_node_modules_mini_css_extract_plugin_0_7_0_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_0_28_11_css_loader_index_js_node_modules_vue_loader_15_7_1_vue_loader_lib_loaders_stylePostLoader_js_node_modules_vue_loader_15_7_1_vue_loader_lib_index_js_vue_loader_options_map_vue_vue_type_style_index_0_id_0d26af56_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/_vue-style-loader@4.1.2@vue-style-loader!../../../node_modules/_mini-css-extract-plugin@0.7.0@mini-css-extract-plugin/dist/loader.js!../../../node_modules/_css-loader@0.28.11@css-loader!../../../node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/_vue-loader@15.7.1@vue-loader/lib??vue-loader-options!./map.vue?vue&type=style&index=0&id=0d26af56&scoped=true&lang=css& */ \"./node_modules/_vue-style-loader@4.1.2@vue-style-loader/index.js!./node_modules/_mini-css-extract-plugin@0.7.0@mini-css-extract-plugin/dist/loader.js!./node_modules/_css-loader@0.28.11@css-loader/index.js!./node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/stylePostLoader.js!./node_modules/_vue-loader@15.7.1@vue-loader/lib/index.js?!./src/components/bdMaps/map.vue?vue&type=style&index=0&id=0d26af56&scoped=true&lang=css&\");\n/* harmony import */ var _node_modules_vue_style_loader_4_1_2_vue_style_loader_index_js_node_modules_mini_css_extract_plugin_0_7_0_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_0_28_11_css_loader_index_js_node_modules_vue_loader_15_7_1_vue_loader_lib_loaders_stylePostLoader_js_node_modules_vue_loader_15_7_1_vue_loader_lib_index_js_vue_loader_options_map_vue_vue_type_style_index_0_id_0d26af56_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_4_1_2_vue_style_loader_index_js_node_modules_mini_css_extract_plugin_0_7_0_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_0_28_11_css_loader_index_js_node_modules_vue_loader_15_7_1_vue_loader_lib_loaders_stylePostLoader_js_node_modules_vue_loader_15_7_1_vue_loader_lib_index_js_vue_loader_options_map_vue_vue_type_style_index_0_id_0d26af56_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_4_1_2_vue_style_loader_index_js_node_modules_mini_css_extract_plugin_0_7_0_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_0_28_11_css_loader_index_js_node_modules_vue_loader_15_7_1_vue_loader_lib_loaders_stylePostLoader_js_node_modules_vue_loader_15_7_1_vue_loader_lib_index_js_vue_loader_options_map_vue_vue_type_style_index_0_id_0d26af56_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_vue_style_loader_4_1_2_vue_style_loader_index_js_node_modules_mini_css_extract_plugin_0_7_0_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_0_28_11_css_loader_index_js_node_modules_vue_loader_15_7_1_vue_loader_lib_loaders_stylePostLoader_js_node_modules_vue_loader_15_7_1_vue_loader_lib_index_js_vue_loader_options_map_vue_vue_type_style_index_0_id_0d26af56_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_vue_style_loader_4_1_2_vue_style_loader_index_js_node_modules_mini_css_extract_plugin_0_7_0_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_0_28_11_css_loader_index_js_node_modules_vue_loader_15_7_1_vue_loader_lib_loaders_stylePostLoader_js_node_modules_vue_loader_15_7_1_vue_loader_lib_index_js_vue_loader_options_map_vue_vue_type_style_index_0_id_0d26af56_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default.a); \n\n//# sourceURL=webpack:///./src/components/bdMaps/map.vue?");

/***/ }),

/***/ "./src/components/bdMaps/map.vue?vue&type=template&id=0d26af56&scoped=true&":
/*!**********************************************************************************!*\
  !*** ./src/components/bdMaps/map.vue?vue&type=template&id=0d26af56&scoped=true& ***!
  \**********************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_15_7_1_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_15_7_1_vue_loader_lib_index_js_vue_loader_options_map_vue_vue_type_template_id_0d26af56_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/_vue-loader@15.7.1@vue-loader/lib??vue-loader-options!./map.vue?vue&type=template&id=0d26af56&scoped=true& */ \"./node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/templateLoader.js?!./node_modules/_vue-loader@15.7.1@vue-loader/lib/index.js?!./src/components/bdMaps/map.vue?vue&type=template&id=0d26af56&scoped=true&\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_vue_loader_15_7_1_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_15_7_1_vue_loader_lib_index_js_vue_loader_options_map_vue_vue_type_template_id_0d26af56_scoped_true___WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_vue_loader_15_7_1_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_15_7_1_vue_loader_lib_index_js_vue_loader_options_map_vue_vue_type_template_id_0d26af56_scoped_true___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n\n\n//# sourceURL=webpack:///./src/components/bdMaps/map.vue?");

/***/ }),

/***/ "./src/unit/layer/Polygon.Draw.js":
/*!****************************************!*\
  !*** ./src/unit/layer/Polygon.Draw.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Polygon_Plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Polygon.Plugin */ \"./src/unit/layer/Polygon.Plugin.js\");\n\n// import store from 'src/store';\nconst markerImg = '../../assets/img/HT.png';\n\n/**\n * 多边形.绘图\n */\nconst PolygonDraw = {\n    data: function () {\n        return {\n            stylePolygon: {\n                strokeColor: 'red', // 边线颜色。\n                fillColor: 'red', // 填充颜色。当参数为空时，圆形将没有填充效果。\n                strokeWeight: 2, // 边线的宽度，以像素为单位。\n                strokeOpacity: 0.8, // 边线透明度，取值范围0 - 1。\n                fillOpacity: 0.6, // 填充的透明度，取值范围0 - 1。\n                strokeStyle: 'solid' // 边线的样式，solid或dashed。\n            },\n            styleMarker: {\n                icon: new BMap.Icon(markerImg, new BMap.Size(8, 8)), // 点上的实心图标\n                enableClicking: false // 是否可点击\n            },\n            snappable: false, // 鼠标吸附功能开关\n            prohibitSelfIntersection: true, // 禁止自相交开关\n            doesSelfIntersect: false, // 当前区域是否自交\n            enabledDraw: false, // 绘图状态\n            hintMarker: null, // 吸附marker\n            hintLabel: null, // 提示标题\n            polygon: null,\n            points: [],\n            markers: [], // 节点上的marker集合\n            updateLabelDate: null // 修改提示标题后的计时时间\n        };\n    },\n    methods: {\n\n        /**\n         * 启用绘图模式\n         */\n        enableDraw () {\n            // debugger\n            if (!this.map) {\n                return;\n            }\n\n            if (this.enabledDraw) {\n                return;\n            }\n\n            // 全国视图模式下，禁止画图\n            if (this.map.getZoom() <= 8) {\n                return;\n            }\n\n            // 启用绘图模式\n            this.enabledDraw = true;\n\n            // 添加Marker光标(必须初始坐标，否则最大地图级别添加空坐标marker时，覆盖物有少量偏移问题)\n            this.hintMarker = new BMap.Marker(new BMap.Point(116.404, 39.915), this.styleMarker);\n            this.map.addOverlay(this.hintMarker);\n\n            // 添加提示标签\n            this.hintLabel = new BMap.Label('', {offset: new BMap.Size(5, -25)});\n            // 禁止隐藏标注\n            this.hintLabel.setStyle({visibility: 'visible'});\n\n            // 添加多边形区域\n            this.polygon = new MapZJS.Polygon({}, Object.assign({enableClicking: false}, this.stylePolygon));\n            this.polygon.setStrokeWeight(2);\n            this.map.addOverlay(this.polygon);\n\n            // 修改地图光标\n            this.map.setDefaultCursor('crosshair');\n\n            // 临时关闭地图双击放大\n            this.map.disableDoubleClickZoom();\n\n            // 单击创建一个多边形节点\n            this.map.addEventListener('click', this.clickAction);\n\n            // 双击完成绘制\n            this.map.addEventListener('dblclick', this.dblclickAction);\n\n            // 移动同步提示线\n            this.map.addEventListener('mousemove', this.moveHintMarker);\n\n            // 右键单击移除一个节点\n            this.map.addEventListener('rightclick', this.rightClickAction);\n\n            // 按下Esc事件 停用绘图模式\n            document.addEventListener('keydown', this.escAction);\n        },\n\n        /**\n         * 停用绘图模式\n         */\n        disableDraw () {\n            if (!this.enabledDraw) {\n                return;\n            }\n\n            // 停用绘图模式\n            this.enabledDraw = false;\n\n            // 清理吸附数据\n            if (this.snappable) {\n                _Polygon_Plugin__WEBPACK_IMPORTED_MODULE_0__[\"Snapping\"]._cleanupSnapping();\n            }\n\n            // 移除Marker光标\n            this.map.removeOverlay(this.hintMarker);\n\n            // 移除提示标题\n            this.map.removeOverlay(this.hintLabel);\n\n            // 移除多边形\n            this.map.removeOverlay(this.polygon);\n\n            this.markers.forEach(m => {\n                this.map.removeOverlay(m);\n            });\n\n            // 清空数据\n            this.points = [];\n            this.markers = [];\n            this.hintMarker = null;\n            this.hintLabel = null;\n            this.polygon = null;\n\n            // 还原地图双击放大\n            this.map.enableDoubleClickZoom();\n\n            // 解除监听事件\n            this.map.removeEventListener('click', this.clickAction);\n            this.map.removeEventListener('dblclick', this.dblclickAction);\n            this.map.removeEventListener('mousemove', this.moveHintMarker);\n            this.map.removeEventListener('rightclick', this.rightClickAction);\n            // 按下Esc事件 停用绘图模式\n            document.removeEventListener('keydown', this.escAction);\n\n            // 重置地图光标\n            this.map.setDefaultCursor('url(\\'http://api0.map.bdimg.com/images/openhand.cur\\'), default');\n        },\n        // 切换绘图模式\n        toggleDraw () {\n            if (this.enabledDraw) {\n                this.disableDraw();\n            } else {\n                this.enableDraw();\n            }\n        },\n        setLabelText (text, styles) {\n            // 提示错误信息后 2秒内不可修改标题\n            if (this.updateLabelDate) {\n                var now = new Date();\n                if (now - this.updateLabelDate < 1000 * 2) {\n                    return;\n                } else {\n                    this.updateLabelDate = null;\n                }\n            }\n\n            // 默认修改标题背景成白色\n            this.hintLabel.setStyle({backgroundColor: 'white'});\n            // 节点为空 则移除提示标题\n            if (this.points == null || this.points.length === 0) {\n                this.map.removeOverlay(this.hintLabel);\n            } else if (text) {\n                // 如果有传入文本 则为错误提示标题\n                this.hintLabel.setContent(text);\n                // 背景改为黄色\n                this.hintLabel.setStyle({backgroundColor: 'yellow'});\n                // 初始化计时器 暂时不可改变标题\n                this.updateLabelDate = new Date();\n            } else if (this.doesSelfIntersect) {\n                this.hintLabel.setContent('不能交叉画图');\n            } else if (this.points.length === 1) {\n                this.map.addOverlay(this.hintLabel);\n                this.hintLabel.setContent('点击继续绘制');\n            } else if (this.points.length >= 2) {\n                this.hintLabel.setContent('点击继续绘制，双击结束，右键回退，Esc键清除');\n            }\n        },\n        /**\n         * 删除一个节点\n         */\n        deleteAPoint () {\n            // 删除最后一个节点\n            this.points.pop();\n\n            // 移除节点对应的marker\n            this.map.removeOverlay(this.markers[this.markers.length - 1]);\n            this.markers.pop();\n\n            // 拼接一个临时点 位置为提示marker坐标\n            var drawPoint = this.points.concat(this.hintMarker.getPosition());\n\n            // 设置区域坐标点\n            this.polygon.setPath(drawPoint);\n        },\n        escAction (e) {\n            e || window.event;\n            // 点击键盘Esc键\n            if (e.keyCode === 27) {\n                this.disableDraw();\n            }\n        },\n        _handleSelfIntersection () {\n            // 防止低版本浏览器单击事件触发移动事件\n            // 扩展运算符数组深拷贝\n            let [...paths] = this.polygon.getPath();\n            // 如果最后一个点与提示marker光标坐标相同，则移除最后一个点\n            if (this.points.length >= 3 && _Polygon_Plugin__WEBPACK_IMPORTED_MODULE_0__[\"ClipperLib\"].op_Equality(this.points[this.points.length - 1], this.hintMarker.getPosition())) {\n                paths.pop();\n            }\n\n            // 好的，我们需要检查这里的自相交。\n            // 检查自相交\n            this.doesSelfIntersect = _Polygon_Plugin__WEBPACK_IMPORTED_MODULE_0__[\"ClipperLib\"].containKinks(_Polygon_Plugin__WEBPACK_IMPORTED_MODULE_0__[\"GeoJSON\"].toGeoJSON(paths));\n\n            // 修改自交样式\n            if (this.doesSelfIntersect) {\n                // this.polygon.setStrokeColor('red');\n                this.setLabelText();\n            } else {\n                // this.polygon.setStrokeColor(this.stylePolygon.strokeColor);\n                this.setLabelText();\n            }\n        },\n        // 鼠标移动事件\n        moveHintMarker (e) {\n            e = e || window.event;\n            // const point = publicMethod.compatibleOffset(this.map, e);\n            const point = e.point;\n            // 同步提示标题\n            this.hintLabel.setPosition(point);\n            // 同步marker光标\n            this.hintMarker.setPosition(point);\n            // 同步区域临时节点\n            this.polygon.setPositionAt(this.points.length, point);\n            // 如果启用了吸附功能，就执行它\n            if (this.snappable) {\n                // 假拖动事件 = 鼠标移动事件\n                const fakeDragEvent = e;\n                fakeDragEvent.target = this.hintMarker; // target 目标是 圆点提示光标\n                fakeDragEvent.polygon = this.polygon; // polygon 多边形覆盖物\n                _Polygon_Plugin__WEBPACK_IMPORTED_MODULE_0__[\"Snapping\"]._handleSnapping(fakeDragEvent); // 处理吸附函数\n            }\n\n            // 如果禁止了自相交，就执行它\n            // 暂停自交验证：单击事件触发的鼠标移动事件不执行自交验证，防止单击添加Marker后边框变红\n            if (this.prohibitSelfIntersection) {\n                this._handleSelfIntersection();\n            }\n        },\n        // 右键回退\n        rightClickAction () {\n            if (this.points.length === 0) {\n                return;\n            }\n\n            // 删除最后一个节点\n            this.deleteAPoint();\n\n            // 如果禁止了自相交，就执行它\n            if (this.prohibitSelfIntersection) {\n                this._handleSelfIntersection();\n            }\n        },\n        // 鼠标单击事件\n        clickAction () {\n            // 点数组长度大于 1 并且 点数组最后一个点坐标与当前点坐标相等\n            // 防止创建相同点和自交点\n            if (this.points.length > 1 && _Polygon_Plugin__WEBPACK_IMPORTED_MODULE_0__[\"ClipperLib\"].op_Equality(this.points[this.points.length - 1], this.hintMarker.getPosition())) {\n                return false;\n            }\n\n            this.points.push(this.hintMarker.getPosition());\n            // 在当前位置拼接一个动态点，跟随鼠标移动\n            var drawPoint = this.points.concat(this.hintMarker.getPosition());\n            this.polygon.setPath(drawPoint);\n\n            // 节点提示\n            let marker = new BMap.Marker(this.hintMarker.getPosition(), this.styleMarker);\n            this.map.addOverlay(marker);\n            this.markers.push(marker);\n\n            // 设置提示标题\n            this.setLabelText();\n        },\n        // 鼠标双击事件\n        dblclickAction () {\n            // 点数组长度 小于 3个坐标点 或 当前区域自交\n            if (this.points.length < 3) return;\n            if (this.doesSelfIntersect) {\n                // 双击保存失败时，不添加点，移除最后一个点\n                // 删除最后一个节点\n                this.deleteAPoint();\n                return;\n            }\n            this.polygon.setPath(this.points);\n            // 取消esc 防止esc清除区域控制台报错\n            document.removeEventListener('keydown', this.escAction);\n            // 先关闭拆分模式 （防止裁剪出现细线问题）\n            // if (this.$store.state.splitPolygonType) MapZJS.Polyline.prototype.completeClear();\n            // this.$store.commit('updateFullscreenLoadingMessage', '');\n            // this.$store.commit('updateFullscreenLoading', true);\n            setTimeout(() => {\n                try {\n                    // 处理裁剪去重 (要裁剪的区域, 地图上的所有覆盖物)\n                    const results = _Polygon_Plugin__WEBPACK_IMPORTED_MODULE_0__[\"Clipper\"].execute(this.polygon, this.map.getOverlays());\n                    // 添加裁剪后的区域 边线宽度覆盖为1\n                    let _polygon = new MapZJS.Polygon(results, Object.assign(this.stylePolygon, {strokeWeight: 1}));\n                    // 生成唯一ID\n                    _polygon.customId = _Polygon_Plugin__WEBPACK_IMPORTED_MODULE_0__[\"AreaPath\"].generateUUID();\n                    // if (store.state.dtc) {\n                    //     _polygon.dtc = true;\n                    //     _polygon.setStrokeColor('yellow'); // 边线颜色。\n                    //     _polygon.setFillColor('yellow'); // 边线颜色。\n                    // }\n                    this.map.addOverlay(_polygon);\n\n                    // 添加单击打开信息窗口\n                    _polygon.addEventListener('click', e => {\n                        // this.addInfoWindow({}, _polygon, e.point, this.hasPermission('drawLayer'));\n                    });\n\n                    // 打开编辑信息窗口\n                    // this.addInfoWindowUpdate({}, _polygon, _polygon.getBounds().getCenter());\n\n                    // 关闭绘图\n                    this.disableDraw();\n                    // this.$store.commit('updateFullscreenLoading', false);\n                } catch (error) {\n                    // 删除最后一个节点\n                    this.deleteAPoint();\n                    // this.$store.commit('updateFullscreenLoading', false);\n                    // 按下Esc事件 停用绘图模式\n                    document.addEventListener('keydown', this.escAction);\n                    if (error.name === 'ClipperError') {\n                        this.setLabelText(error.message);\n                        return;\n                    }\n                    console.error('Polygon.Draw.js--dblclickAction方法异常', error);\n                }\n            }, 500);\n        },\n        // 线段中心区域\n        centralPosition (lineArr) {\n            let turfLineArr = _Polygon_Plugin__WEBPACK_IMPORTED_MODULE_0__[\"GeoJSON\"].toGeoJSON(lineArr);\n            let turfLine = turf.lineString(turfLineArr.geometry.coordinates[0]);\n            let options = {units: 'miles'};\n            let along = turf.along(turfLine, 200, options);\n            let turfPontArr = [\n                {\n                    lng: along.geometry.coordinates[0],\n                    lat: along.geometry.coordinates[1]\n                }\n            ];\n            return _Polygon_Plugin__WEBPACK_IMPORTED_MODULE_0__[\"GeoJSON\"].toGeoJSON(turfPontArr).geometry.coordinates[0][0];\n        }\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (PolygonDraw);\n\n\n//# sourceURL=webpack:///./src/unit/layer/Polygon.Draw.js?");

/***/ }),

/***/ "./src/unit/layer/Polygon.Plugin.js":
/*!******************************************!*\
  !*** ./src/unit/layer/Polygon.Plugin.js ***!
  \******************************************/
/*! exports provided: GeoJSON, ClipperLib, Clipper, LineUtil, Snapping, AreaPath, regionSplit, regionMerge, publicMethod */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoJSON\", function() { return GeoJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClipperLib\", function() { return ClipperLib; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Clipper\", function() { return Clipper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineUtil\", function() { return LineUtil; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Snapping\", function() { return Snapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AreaPath\", function() { return AreaPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"regionSplit\", function() { return regionSplit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"regionMerge\", function() { return regionMerge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"publicMethod\", function() { return publicMethod; });\n/// ///////////////// GeoJSON对象转换工具 //////////////////////////\n\nconst GeoJSON = {\n    /**\n     * 转多边形\n     * @param coordinates\n     * @returns {MapZJS.Polygon}\n     */\n    toPolygon: function (coordinates) {\n        let points = [];\n        coordinates.forEach((arr) => {\n            points.push(new BMap.Point(arr[0], arr[1]));\n        });\n        return new MapZJS.Polygon(points.slice(0, points.length - 1));\n    },\n    /**\n     * 转GeoJSON对象\n     * @param _latlngs\n     * area 默认转化面 false 转化线\n     * @returns {*}\n     */\n    toGeoJSON: function (_latlngs, area = true) {\n        var coords = this._latLngsToCoords(_latlngs, 0, area);\n        coords = [coords];\n\n        return this._getFeature(this, {\n            type: 'Polygon',\n            coordinates: coords\n        });\n    },\n    /**\n     * 经纬度转坐标, lat lng 转 GeoJSON\n     * @param latlngs\n     * @param levelsDeep\n     * @param closed\n     * @returns {Array}\n     */\n    _latLngsToCoords: function (latlngs, levelsDeep, closed) {\n        var coords = [];\n\n        for (var i = 0, len = latlngs.length; i < len; i++) {\n            coords.push(levelsDeep\n                ? this._latLngsToCoords(latlngs[i], levelsDeep - 1, closed)\n                : this._latLngToCoords(latlngs[i]));\n        }\n\n        if (!levelsDeep && closed) {\n            coords.push(coords[0]);\n        }\n\n        return coords;\n    },\n    _latLngToCoords: function (latlng) {\n        return [latlng.lng, latlng.lat];\n    },\n    _getFeature: function (layer, newGeometry) {\n        if (!layer.feature) return this._asFeature(newGeometry);\n    },\n    _asFeature: function (geojson) {\n        if (geojson.type === 'Feature') {\n            return geojson;\n        }\n        return {\n            type: 'Feature',\n            properties: {},\n            geometry: geojson\n        };\n    }\n};\n\n/// ////////////// 裁剪工具 /////////////////\n\nconst ClipperLib = {\n    /**\n     * 包含自交点\n     * @param poly\n     * @returns {boolean}\n     */\n    containKinks (poly) {\n        const kinks = turf.kinks(poly); // 返回所有自交点位置\n        return kinks.features.length > 0; // 自交点大于0 则是错误图形\n    },\n    /**\n     * 坐标点相等\n     * @param a\n     * @param b\n     * @returns {boolean}\n     */\n    op_Equality (a, b) {\n        // return a == b;\n        return a.lng === b.lng && a.lat === b.lat;\n    },\n    /**\n     * 坐标点不等\n     * @param a\n     * @param b\n     * @returns {boolean}\n     */\n    op_Inequality (a, b) {\n        // return a != b;\n        return a.lng !== b.lng || a.lat !== b.lat;\n    },\n    /**\n     * 坐标后七位转整数\n     * 四舍五入后的整数\n     * @param x\n     * @returns {Number}\n     * @private\n     */\n    _sevenDecimalTointegers (x) {\n        var fX = parseFloat(x);\n        if (isNaN(fX)) {\n            return false;\n        }\n        fX = Math.round(fX * 10000000);\n        return fX;\n    },\n    /**\n     * 相似坐标点\n     * 坐标差异在±2之间即相似\n     * @param a\n     * @param b\n     * @returns {boolean}\n     * @private\n     */\n    _sevenDecimalResemble (a, b) {\n        const alng = this._sevenDecimalTointegers(a.lng);\n        const alat = this._sevenDecimalTointegers(a.lat);\n        const blng = this._sevenDecimalTointegers(b.lng);\n        const blat = this._sevenDecimalTointegers(b.lat);\n        return Math.abs(alng - blng) <= 90 && Math.abs(alat - blat) <= 90;\n    },\n    /**\n     * 擦除冗余点\n     * @param poly 裁剪后的区域\n     * @returns {Array}\n     */\n    erasingPoints (poly) {\n        let a = poly;\n        let b = [a[0]];\n        for (let i = 1; i < a.length; i++) {\n            if (!this._sevenDecimalResemble(a[i - 1], a[i])) {\n                b.push(a[i]);\n            }\n        }\n        return b;\n    },\n    /**\n     * 简化区域节点\n     * tolerance: 简化范围值(值越大，简化范围越大)\n     * highQuality: 是否花费更多时间用不同的算法创建更高质量的简化\n     * mutate：允许改变GeoJSON输入（如果为真，则显著提高性能）\n     * layer: 图层区域\n     */\n    simplified (parameter) {\n        // 默认值\n        let defOptions = {\n            highQuality: true,\n            mutate: true,\n            tolerance: 0.0001\n        };\n        // 合并参数\n        Object.assign(defOptions, parameter);\n        // 简化节点参数\n        let options = {\n            tolerance: defOptions.tolerance,\n            highQuality: defOptions.highQuality,\n            mutate: defOptions.mutate\n        };\n        // 简化区域\n        let simplified;\n        try {\n            simplified = turf.simplify(defOptions.layer, options);\n        } catch (e) {\n            throw new ClipperError('简化节点有误，请重新画图', 1002);\n        }\n        // 转换成百度坐标\n        let coordinate = GeoJSON.toPolygon(simplified.geometry.coordinates[0]).getPath();\n        if (coordinate.length < 3) throw new ClipperError('区域不符合规则', 1004);\n        return coordinate;\n    }\n};\n\n/// ///////////////////// 裁剪去重 /////////////////////////////////\n\n// 定义 裁剪错误类\nclass ClipperError extends Error {\n    constructor (message, type) {\n        super(message);\n        this.name = 'ClipperError';\n        this.type = type || -1;\n        this.message = message || '自动去重失败';\n    }\n}\n\nconst Clipper = {\n    /**\n     * 执行去重\n     * @param _polygon 去重区域\n     * @param _layers 覆盖物数组\n     * @returns {*|Array}\n     */\n    execute (_polygon, _layers) {\n        var polygonGeo = GeoJSON.toGeoJSON(_polygon.getPath());\n        if (ClipperLib.containKinks(polygonGeo)) {\n            // console.error('裁剪区域包含自交点');\n            throw new ClipperError('不能交叉画图', 1001);\n        }\n        // 找到所有与之相交的多边形覆盖物\n        _layers = _layers\n        // 覆盖物是可见的\n            .filter(l => l.isVisible())\n            // 覆盖物是多边形\n            .filter(l => l instanceof MapZJS.Polygon)\n            // 覆盖物非当前区域\n            .filter(l => l !== _polygon)\n            // 覆盖物非自相交\n            .filter(l => !ClipperLib.containKinks(GeoJSON.toGeoJSON(l.getPath())))\n            // 与之相交的\n            .filter((l) => {\n                try {\n                    let buffered = turf.buffer(GeoJSON.toGeoJSON(l.getPath()), -1, {units: 'meters'});\n                    if (buffered.geometry.coordinates.length > 1) return true; // 将不规则图形返回到下一层级判断\n                    return !!turf.intersect(polygonGeo, buffered);\n                } catch (e) {\n                    if (l.getPath().length > 2) return true;\n                }\n            });\n        // 去重\n        let points = this._cutting(_layers, _polygon);\n\n        // 简化区域参数\n        let simOptions = {\n            tolerance: 0.00001,\n            layer: GeoJSON.toGeoJSON(points.getPath())\n        };\n        return ClipperLib.simplified(simOptions);\n    },\n    /**\n     * 裁剪\n     * @param _layers 重叠多边形数组\n     * @param _polygon 裁剪区域\n     * @param frequency 递归次数\n     * @returns {*} 裁剪后的多边形区域\n     * @private\n     */\n    _cutting (_layers, _polygon, frequency = 5) {\n        this._solution = _polygon;\n        _layers.forEach((l) => {\n            // 裁剪参照物添加缓冲区 1毫米\n            var buffered = turf.buffer(GeoJSON.toGeoJSON(l.getPath()), 0.001, {units: 'meters'});\n            let diff = null;\n            try {\n                // 发现不同层\n                diff = turf.difference(GeoJSON.toGeoJSON(this._solution.getPath()), buffered);\n            } catch (e) {\n                // console.error(e);\n            }\n            // 裁剪区域被完全覆盖的情况下，返回null\n            if (!diff) {\n                /** return console.error('裁剪区域被其它区域完全覆盖'); */\n                throw new ClipperError('所画区域在原有区域内，完全重合，请重新画图', 1002);\n            }\n            // 如果结果是多多边形，将它分割成规则的多边形\n            if (diff.geometry.type === 'MultiPolygon') {\n                if (store.state.mergeObj.infoType) throw new ClipperError('合并失败，待合并区域间存在另一区域', 1006);\n                const geoJSONs = diff.geometry.coordinates.reduce((arr, coords) => {\n                    arr.push({type: 'Polygon', coordinates: coords});\n                    return arr;\n                }, []);\n\n                // 只取多多边形数组中的第一个多边形\n                this._solution = GeoJSON.toPolygon(geoJSONs[0].coordinates[0]);\n            } else {\n                if (diff.geometry.coordinates.length > 1) {\n                    /** console.error('裁剪区域完全覆盖其它区域'); */\n                    throw new ClipperError('将原有区域完全覆盖，请重新画图', 1003);\n                }\n                this._solution = GeoJSON.toPolygon(diff.geometry.coordinates[0]);\n            }\n        });\n        return this._solution;\n    },\n    kinksPointOut (_polygon) {\n        // if(_polygon.timeout != null && new Date() - _polygon.timeout < 1000 * 10){\n        //     return;\n        // }\n        // _polygon.timeout = new Date();\n\n        // 获取map地图对象\n        const _map = _polygon.getMap();\n\n        // 如果区域已有自交节点数组 则清除marker\n        if (_polygon.kindsMarkers != null) {\n            _polygon.kindsMarkers.forEach(m => {\n                _map.removeOverlay(m);\n            });\n        }\n        _polygon.kindsMarkers = [];\n\n        // 获取相交坐标\n        let polygonGeo = GeoJSON.toGeoJSON(_polygon.getPath());\n        const kinks = turf.kinks(polygonGeo); // 返回所有自交点位置\n\n        if (kinks.features.length > 0) {\n            kinks.features.forEach(f => {\n                // 图标 显示1、2、3\n                let icon = new BMap.Icon('/static/img/shu.png', new BMap.Size(23, 25), {\n                    anchor: new BMap.Size(10, 25), // 指定定位位置\n                    imageOffset: new BMap.Size(0, -250) // 设置图片偏移\n                });\n                // 坐标\n                let point = new BMap.Point(f.geometry.coordinates[0], f.geometry.coordinates[1]);\n                // marker\n                let marker = new BMap.Marker(point, {icon: icon});\n                marker.disableMassClear(); // 禁止map.clearOverlays方法清除。\n                // 层级低于编辑节点的空心实心点\n                marker.setZIndex(0);\n                _map.addOverlay(marker);\n                var label = new BMap.Label('', {offset: new BMap.Size(5, 10)});\n                marker.addEventListener('mouseover', () => {\n                    label.setContent('右键删除! ');\n                    label.setPosition(marker.getPosition());\n                    _map.addOverlay(label);\n                });\n                marker.addEventListener('mouseout', function (e) {\n                    _map.removeOverlay(label);\n                });\n                marker.addEventListener('rightclick', () => {\n                    _map.removeOverlay(marker);\n                    _map.removeOverlay(label);\n                });\n                _polygon.kindsMarkers.push(marker);\n                // marker.setAnimation(BMAP_ANIMATION_BOUNCE); // 跳动\n                //\n                // setTimeout(() => {\n                //     marker.setAnimation(null);\n                // }, 3000);\n                // setTimeout(() => {\n                //     _map.removeOverlay(marker);\n                // }, 10000);\n            });\n        }\n        return kinks.features.length;\n    }\n};\n\n/// /////////////////////////// 吸附工具 /////////////////////////////////////\nconst LineUtil = {\n    /**\n     * 返回点“p”到“A”和“B”段之间的距离\n     * @param p\n     * @param p1\n     * @param p2\n     * @returns {Number}\n     */\n    pointToSegmentDistance: function (p, p1, p2) {\n        return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));\n    },\n    /**\n     * 返回从点'p'到'p1'和'p2'段上的最近点\n     * @param p\n     * @param p1\n     * @param p2\n     * @returns {*}\n     */\n    closestPointOnSegment: function (p, p1, p2) {\n        return this._sqClosestPointOnSegment(p, p1, p2);\n    },\n    /**\n     * 返回两点之间的像素距离\n     * @param map\n     * @param latlngA\n     * @param latlngB\n     * @returns {number}\n     * @private\n     */\n    _getDistance (map, latlngA, latlngB) {\n        var A = map.pointToPixel(latlngA);\n        var B = map.pointToPixel(latlngB);\n        var x = A.x - B.x,\n            y = A.y - B.y;\n\n        return Math.sqrt(x * x + y * y);\n    },\n    /**\n     * 得到点到段的距离\n     * @param map\n     * @param latlng\n     * @param latlngA\n     * @param latlngB\n     * @returns {*|Number}\n     * @private\n     */\n    _getDistanceToSegment (map, latlng, latlngA, latlngB) {\n        const P = map.pointToPixel(latlng); // 经纬度坐标转换为像素坐标\n        const A = map.pointToPixel(latlngA);\n        const B = map.pointToPixel(latlngB);\n\n        return this.pointToSegmentDistance(P, A, B); // 点到段距离 // 返回点“p”到“A”和“B”段之间的距离\n    },\n    /**\n     * 得到点到段上最近的点\n     * @param map\n     * @param latlng\n     * @param latlngA\n     * @param latlngB\n     * @returns {*}\n     * @private\n     */\n    _getClosestPointOnSegment (map, latlng, latlngA, latlngB) {\n        const P = map.pointToPixel(latlng); // 经纬度坐标转换为像素坐标\n        const A = map.pointToPixel(latlngA);\n        const B = map.pointToPixel(latlngB);\n        const closest = this.closestPointOnSegment(P, A, B); // 点到段上最近的点 // 返回从点'p'到'p1'和'p2'段上的最近点\n        return map.pixelToPoint(closest);\n    },\n    /**\n     * 返回在该点上的最接近点或距离\n     * @param p\n     * @param p1\n     * @param p2\n     * @param sqDist\n     * @returns {*}\n     * @private\n     */\n    _sqClosestPointOnSegment: function (p, p1, p2, sqDist) {\n        var x = p1.x,\n            y = p1.y,\n            dx = p2.x - x,\n            dy = p2.y - y,\n            dot = dx * dx + dy * dy,\n            t;\n\n        if (dot > 0) {\n            t = ((p.x - x) * dx + (p.y - y) * dy) / dot;\n\n            if (t > 1) {\n                x = p2.x;\n                y = p2.y;\n            } else if (t > 0) {\n                x += dx * t;\n                y += dy * t;\n            }\n        }\n\n        dx = p.x - x;\n        dy = p.y - y;\n\n        return sqDist ? dx * dx + dy * dy : new BMap.Pixel(x, y);\n    },\n    /**\n     * 将节点数组拼接成字符串\n     * 如：116.395354,39.93329;116.396881,39.931997\n     * @param paths\n     * @returns {string}\n     */\n    toPathString (paths, reversal = false) {\n        let lngLat = '';\n        for (var i = 0; i < paths.length; i++) {\n            var lng = paths[i].lng;\n            var lat = paths[i].lat;\n            if (reversal) {\n                lngLat += lat + ',' + lng + ';';\n            } else {\n                lngLat += lng + ',' + lat + ';';\n            }\n        }\n        if (lngLat.length > 0) {\n            // 截掉最后的分号；\n            lngLat = lngLat.substr(0, lngLat.length - 1);\n        }\n        return lngLat;\n    },\n    /**\n     * 获取直线上中心点\n     * @param A 点\n     * @param B 点\n     * @returns {Point} 中心点\n     */\n    getCenterPoint (A, B) {\n        var lat = ((A.lat + B.lat) / 2).toFixed(6);\n        var lng = ((A.lng + B.lng) / 2).toFixed(6);\n        var C = new BMap.Point(lng, lat);\n        return C;\n    }\n};\n\n/// //////////////////// 吸附功能 //////////////////////////////\nconst Snapping = {\n    /**\n     * 处理吸附\n     * @param e\n     * @returns {boolean}\n     * @private\n     */\n    _handleSnapping (e) {\n        // 按住Alt键 移动marker则暂停吸附效果\n        if (e.altKey) {\n            return false;\n        }\n\n        this._map = e.target.getMap();\n        const marker = e.target;\n        const polygon = e.polygon;\n        // 创建一个标记可以吸附到的多边形列表。\n        if (this._snapList === undefined) {\n            // _snapList 将所有符合条件的层添加到吸附集合中\n            Snapping._createSnapList(polygon);\n        }\n\n        // 如果没有层来捕捉，停在这里\n        if (this._snapList.length <= 0) {\n            return false;\n        }\n\n        // 得到最近的层，它是最接近latlng的段与距离。\n        const closestLayer = Snapping._calcClosestLayer(marker.getPosition(), this._snapList);\n\n        const isMarker = closestLayer.layer instanceof BMap.Marker;\n\n        // 找到我们想抢占的最后一个\n        let snapLatLng = closestLayer.latlng;\n\n        // 标记捕捉前的最小距离（以像素为单位）\n        this.snapDistance = 20;\n        const minDistance = this.snapDistance;\n        if (!isMarker) {\n            snapLatLng = this._checkPrioritiySnapping(closestLayer);\n        } else {\n            snapLatLng = closestLayer.latlng;\n        }\n\n        // 事件信息PM：捕捉和PM：解扣\n        const eventInfo = {\n            marker,\n            snapLatLng,\n            segment: closestLayer.segment,\n            layer: polygon,\n            layerInteractedWith: closestLayer.layer // 因为缺少更好的属性名。\n        };\n\n        if (closestLayer.distance < minDistance) {\n            // 吸附这个marker\n            marker.setPosition(snapLatLng);\n            polygon.setPositionAt(polygon.getPath().length - 1, snapLatLng);\n\n            marker._snapped = true;\n\n            const triggerSnap = () => {\n                this._snapLatLng = snapLatLng;\n                // marker.fire('pm:snap', eventInfo);\n                // this._layer.fire('pm:snap', eventInfo);\n            };\n\n            // 检查吸附位置是否与最后一个吸附不同。\n            const a = this._snapLatLng || {};\n            const b = snapLatLng || {};\n\n            if (a.lat !== b.lat || a.lng !== b.lng) {\n                triggerSnap(); // 触发吸附\n            }\n        } else if (this._snapLatLng) {\n            // 不再吸附\n\n            // 如果以前被吸附...解扣\n            this._unsnap(eventInfo);\n\n            marker._snapped = false;\n\n            // 并且交火解扣事件\n            // eventInfo.marker.fire('pm:unsnap', eventInfo);\n            // this._layer.fire('pm:unsnap', eventInfo);\n        }\n\n        return true;\n    },\n    /**\n     * 计算最近的层\n     * @param latlng\n     * @param layers\n     * @private\n     */\n    _calcClosestLayer (latlng, layers) {\n        // 最接近我们拖曳标记的多边形\n        let closestLayer = {};\n\n        // 通过层循环\n        layers.forEach((layer, index) => {\n            // 找到最接近的latlng、段和该层到拖动标记latlng的距离。\n            const results = Snapping._calcLayerDistances(latlng, layer); // 计算层距离\n\n            // 如果信息不存在，或者距离小于前一个，则保存该信息。\n            if (closestLayer.distance === undefined || results.distance < closestLayer.distance) {\n                closestLayer = results;\n                closestLayer.layer = layer;\n            }\n        });\n\n        // 返回最近的层和它的数据\n        // 如果没有最接近的层，则返回未定义的\n        return closestLayer;\n    },\n    /**\n     * 计算与层的距离\n     * @param latlng\n     * @param layer\n     * @returns {{latlng: *, segment: *, distance: *}}\n     * @private\n     */\n    _calcLayerDistances (latlng, layer) {\n        // 这是多边形?\n        const isPolygon = layer instanceof MapZJS.Polygon;\n\n        // 我们想要捕捉的点P(被拖动的标记)\n        const P = latlng;\n\n        let coords;\n\n        // 该层的坐标集合\n        if (isPolygon) {\n            // polygon\n            coords = layer.getPath();\n        }\n\n        // 层的最近段（两点之间的线）\n        let closestSegment;\n\n        // 从P到段落的最短距离\n        let shortestDistance;\n\n        // 循环遍历层的坐标\n        coords.forEach((coord, index) => {\n            // 把这个coord(A)\n            const A = coord;\n            let nextIndex;\n\n            // 下一个coord 为点 (B)\n            if (isPolygon) {\n                nextIndex = index + 1 === coords.length ? 0 : index + 1;\n            } else {\n                nextIndex = index + 1 === coords.length ? undefined : index + 1;\n            }\n\n            const B = coords[nextIndex];\n\n            if (B) {\n                // P和ab段之间的距离\n                const distance = LineUtil._getDistanceToSegment(this._map, P, A, B);\n\n                // 距离比上一个短吗?保存它和段\n                if (shortestDistance === undefined || distance < shortestDistance) {\n                    shortestDistance = distance;\n                    closestSegment = [A, B];\n                }\n            }\n        });\n\n        // 现在，取最接近段其上的最近点与p点对齐。\n        const C = LineUtil._getClosestPointOnSegment(this._map, latlng, closestSegment[0], closestSegment[1]);\n\n        // 返回最近段落、最近点和与其距离。\n        return {\n            latlng: C,\n            segment: closestSegment,\n            distance: shortestDistance\n        };\n    },\n\n    /**\n     * 我们得到了我们想要对齐到(C)的点，但是我们需要检查一个多边形的coord。\n     * 以C的优先级作为起始点。让我们在这里检查\n     * @param closestLayer\n     * @returns {*}\n     * @private\n     */\n    _checkPrioritiySnapping (closestLayer) {\n        // A和B是与P最接近的部分的点(我们想要捕捉的标记位置)\n        const A = closestLayer.segment[0];\n        const B = closestLayer.segment[1];\n\n        // C是我们在线段上吸附的点。\n        // 距离最近的多边形的最近部分的最近点，这是对的。\n        const C = closestLayer.latlng;\n\n        // 从A到C和B到C的距离，来检查哪个离C更近。\n        const distanceAC = LineUtil._getDistance(this._map, A, C);\n        const distanceBC = LineUtil._getDistance(this._map, B, C);\n\n        // 最近顶点坐标\n        const closestVertexLatLng = distanceAC < distanceBC ? A : B;\n\n        // 顶点坐标与C之间的最短距离。\n        const shortestDistance = distanceAC < distanceBC ? distanceAC : distanceBC;\n\n        // 需要被削弱以触发优先级的距离\n        const priorityDistance = this.snapDistance;\n\n        // 需要削弱的距离以触发优先权。\n        let snapLatlng;\n\n        // 如果C更接近于近距离(A或B)而不是snapDistance，\n        // 最接近于C的关闭点是最重要的。\n        if (shortestDistance < priorityDistance) {\n            snapLatlng = closestVertexLatLng;\n        } else {\n            snapLatlng = C;\n        }\n\n        // 返回捕捉点\n        return snapLatlng;\n    },\n    /**\n     * 创建吸附集合\n     * @param _polygon\n     * @private\n     */\n    _createSnapList (_polygon) {\n        let layers = [];\n\n        // 多边形编辑的临时标记\n        this._map.getOverlays().forEach((layer) => {\n            // 覆盖物是可见的 // 覆盖物是多边形\n            if (layer.isVisible() && layer instanceof MapZJS.Polygon && layer.getPath().length > 0) {\n                layers.push(layer);\n            }\n        });\n\n        // 保存到吸附集合中_snapList\n        this._snapList = layers;\n    },\n    /**\n     * 清理吸附功能相关数据\n     * @private\n     */\n    _cleanupSnapping () {\n        delete this._snapList;\n    },\n    /**\n     * 解扣\n     * @private\n     */\n    _unsnap () {\n        // delete the last snap\n        delete this._snapLatLng;\n    }\n};\n\n/* 面积路径工具 */\nconst AreaPath = {\n    // 计算面积 平方千米\n    acreage (polygon, decimal = 3) {\n        const selfing = Clipper.kinksPointOut(polygon);\n        if (selfing) return '面积错误';\n        let polygonGeo = GeoJSON.toGeoJSON(polygon.getPath());\n        let poly = turf.polygon([polygonGeo.geometry.coordinates[0]]);\n        let area = (turf.area(poly) / (1000 * 1000));\n        if (area > 0 && area < 0.001) area = 0.001;\n        if (area > 0 && area) return area.toFixed(decimal);\n        return '面积错误';\n    },\n    generateUUID () {\n        var d = new Date().getTime();\n        var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n            var r = (d + Math.random() * 16) % 16 | 0;\n            d = Math.floor(d / 16);\n            return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);\n        });\n        return uuid;\n    }\n};\n\n/* 区域拆分工具 */\nconst regionSplit = {\n    /**\n     * 线分割面\n     * ｛ polyLine：面LineString， clipLine: 线LineString ｝\n     * 注:线与多边形必须有两个交点\n     */\n    singlePolygonClip (polyLine, clipLine) {\n        // 获得面和线的交点\n        const intersects = turf.lineIntersect(polyLine, clipLine);\n        if (intersects.features.length !== 2) {\n            throw new ClipperError('拆分失败，切割线与多边形交点不为2个', 1005);\n        }\n        // 检查切割线与多边形的位置关系 （切割线的起点和终点不能落在多边形内部）\n        const clipLineLength = clipLine.geometry.coordinates.length;\n        const clipLineStartPoint = turf.point(clipLine.geometry.coordinates[0]);\n        const clipLineEndPoint = turf.point(clipLine.geometry.coordinates[clipLineLength - 1]);\n        const polygon = turf.polygon([polyLine.geometry.coordinates]);\n        if (turf.booleanPointInPolygon(clipLineStartPoint, polygon) || turf.booleanPointInPolygon(clipLineEndPoint, polygon)) {\n            throw new ClipperError('拆分失败，切割线起点或终点不能在多边形内部', 1005);\n        }\n        // 通过裁切点 分割多边形\n        let slicedPolyLine = turf.lineSlice(intersects.features[0], intersects.features[1], polyLine);\n        // 裁剪线分割 保留多边形内部部分\n        let slicedClipLine = turf.lineSlice(intersects.features[0], intersects.features[1], clipLine);\n        // 重新拼接多边形 存在 对接的问题 所以先进行判断 如何对接裁剪的多边形和裁剪线\n        let resultPolyline1 = this.connectLine(slicedPolyLine, slicedClipLine);\n        // 闭合线 来构造多边形\n        resultPolyline1.geometry.coordinates.push(resultPolyline1.geometry.coordinates[0]);\n        let resultPolygon1 = turf.lineToPolygon(resultPolyline1);\n        // 区域缓冲使其裁剪成功\n        resultPolygon1 = turf.buffer(resultPolygon1, 1, {units: 'meters'});\n        // 构造切割的另一面多边形\n        let resultPolygon2 = turf.difference(polygon, resultPolygon1);\n        // 还原缓冲区\n        resultPolygon1 = turf.buffer(resultPolygon1, -1, {units: 'meters'});\n        // 节点简化\n        resultPolygon1 = ClipperLib.simplified({tolerance: 0.00001, layer: resultPolygon1});\n        resultPolygon2 = ClipperLib.simplified({tolerance: 0.00001, layer: resultPolygon2});\n\n        return {\n            splitPolygon: resultPolygon1,\n            surplusPolygon: resultPolygon2\n        };\n    },\n    /**\n     * 连接两条线\n     * ｛line1: 多边形裁剪线段, line2：分割线裁剪的线段｝\n     * 方法会将两条线段最近的一段直接连接\n     */\n    connectLine: function (line1, line2) {\n        const line2_length = line2.geometry.coordinates.length;\n        const line1_startPoint = line1.geometry.coordinates[0];\n        const line2_startPoint = line2.geometry.coordinates[0];\n        const line2_endPoint = line2.geometry.coordinates[line2_length - 1];\n\n        let pointList = [];\n        // 获取line1 所有点坐标\n        for (let i = 0; i < line1.geometry.coordinates.length; i++) {\n            let coordinate = line1.geometry.coordinates[i];\n            pointList.push(coordinate);\n        }\n\n        // 判断两条线的 起点是否接近，如果接近 逆转line2线 进行连接\n        if (turf.distance(line1_startPoint, line2_startPoint) < turf.distance(line1_startPoint, line2_endPoint)) {\n            line2.geometry.coordinates = line2.geometry.coordinates.reverse();\n        }\n\n        for (let i = 0; i < line2.geometry.coordinates.length; i++) {\n            let coordinate = line2.geometry.coordinates[i];\n            pointList.push(coordinate);\n        }\n        return turf.lineString(pointList);\n    }\n};\n\n/* 区域合并工具 */\nconst regionMerge = {\n    mergePoly (p1, p2, map) {\n        return new Promise((resolve) => {\n            map.removeOverlay(p1);\n            map.removeOverlay(p2);\n            // 添加缓冲\n            const poly1 = turf.buffer(GeoJSON.toGeoJSON(p1.getPath()), 60, {units: 'meters'});\n            const poly2 = turf.buffer(GeoJSON.toGeoJSON(p2.getPath()), 60, {units: 'meters'});\n            // const b1 = GeoJSON.toPolygon(poly1.geometry.coordinates[0]);\n            // map.addOverlay(b1);\n            // const b2 = GeoJSON.toPolygon(poly2.geometry.coordinates[0]);\n            // map.addOverlay(b2);\n\n            // 合并还原缓冲\n            let union = null;\n            let coordinate = null;\n            try {\n                union = turf.union(poly1, poly2);\n            } catch (e) {\n                throw new ClipperError('合并失败', 1006);\n            }\n            union = turf.buffer(union, -60, {units: 'meters'});\n            if (union.geometry.coordinates.length > 1 && union.geometry.type !== 'Polygon') {\n                throw new ClipperError('两区域间隔大于100m不允许合并，如合并请重新编辑区域', 1006);\n            } else {\n                coordinate = GeoJSON.toPolygon(union.geometry.coordinates[0]);\n            }\n\n            // 去重\n            let SimplifyPoly = new MapZJS.Polygon(Clipper.execute(coordinate, map.getOverlays()));\n            resolve(SimplifyPoly);\n        });\n    }\n};\n\n/* 公用函数工具 */\nconst publicMethod = {\n    // 路径规划模板\n    routeHtml (data, type = 'pathPlan') {\n        let drive, ride;\n        data[0].plan === 'driving' ? (drive = data[0], ride = data[1]) : (drive = data[1], ride = data[0]);\n        let content = '<div class=\"dtwy-infowindow routeWindow\">' +\n            '<div class=\"area-infowin-title\" style=\"margin: 0 20px; padding-left: 0\">' +\n            `${type === 'pathPlan' ? '路径规划' : '自定义规划'}` +\n            '</div>' +\n            '<dl class=\"area-infowin-content routeInfo\">' +\n            '<dt>' +\n            '<li>驾车：</li>' +\n            '<div class=\"drive\">' +\n            `<li>距离：${drive.distance ? drive.distance : drive.error}</li>` +\n            `<li>时间：${drive.duration ? drive.duration : drive.error}</li>` +\n            '</div>' +\n            '</dt>' +\n            '<dd>' +\n            '<li>骑行：</li>' +\n            '<div class=\"ride\">' +\n            `<li>距离：${ride.distance ? ride.distance : ride.error}</li>` +\n            `<li>时间：${ride.duration ? ride.duration : ride.error}</li>` +\n            '</div>' +\n            '</dd>' +\n            '</dl>' +\n            '</div>';\n        return content;\n    },\n    // 关闭按钮\n    createCloseBtn (opts) {\n        let lstPx = opts.map.pointToPixel(opts.startP);\n        let prePx = opts.map.pointToPixel(opts.endP);\n        let btnOffset = [0, 0];\n        // 设置关闭按钮位置\n        lstPx.x - prePx.x >= 0 ? btnOffset = [opts.offset, 0] : btnOffset = [-opts.offset, 0];\n        let closeIcon = new BMap.Icon('http://api.map.baidu.com/images/mapctrls.gif',\n            new BMap.Size(12, 12),\n            {imageOffset: new BMap.Size(0, -14)});\n        let closeBtn = new BMap.Marker(opts.startP,\n            {\n                icon: closeIcon,\n                offset: new BMap.Size(btnOffset[0], btnOffset[1]),\n                baseZIndex: 3600000,\n                enableMassClear: true\n            }\n        );\n        closeBtn.setTitle(opts.tit);\n        opts.map.addOverlay(closeBtn);\n        closeBtn.addEventListener('click', () => {\n            closeBtn.remove();// 移除关闭按钮\n            if (opts.callBack) opts.callBack();\n        });\n        return closeBtn;\n    },\n    // 兼容双核浏览器分辨率不同下的offset\n    compatibleOffset (map, event) {\n        let x, y;\n        if (store.state.fullScreen) {\n            x = event.clientX;\n            y = event.clientY;\n        } else if (store.state.mapZoomFlag && !store.state.fullScreen) {\n            x = event.clientX - 57;\n            y = event.clientY - 54;\n        } else if (!store.state.mapZoomFlag && !store.state.fullScreen) {\n            x = event.clientX - 57 - 330;\n            y = event.clientY - 54;\n        }\n        return map.pixelToPoint(new BMap.Pixel(x, y));\n    }\n};\n\n\n//# sourceURL=webpack:///./src/unit/layer/Polygon.Plugin.js?");

/***/ }),

/***/ "./src/unit/layer/Polygon.js":
/*!***********************************!*\
  !*** ./src/unit/layer/Polygon.js ***!
  \***********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Polygon_Plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Polygon.Plugin */ \"./src/unit/layer/Polygon.Plugin.js\");\n/**\n * @fileOverview 百度地图的自定义多边形覆盖物\n *\n * @author YSL\n * @version 1.0.0\n *\n * @namespace 自定义的library类均放在MapZJS命名空间下\n */\n\n// import store from '../../store';\n\n\nconst MapZJS = window.MapZJS = window.MapZJS || {};\n// 自定义覆盖物的构造函数\nconst Polygon = MapZJS.Polygon = function (point, style) {\n    BMap.Polygon.call(this, point, style);\n};\n\ntry {\n    // 继承多边形类 BMap.Polygon\n    Polygon.prototype = new BMap.Polygon();\n} catch (error) {\n    console.error('IconOverlay.js--地图库加载异常', error);\n}\n\n/**\n * 级联高亮\n */\nPolygon.prototype.cascadeUnit = function () {\n    // 合并的区域\n    if (this.merge) {\n        this.setFillColor('#565294');\n        this.setFillOpacity(0.6);\n        return;\n    }\n\n    // 拆分出的区域\n    if (this.tailoring) {\n        this.setFillColor('green');\n        this.setFillOpacity(0.6);\n        return;\n    }\n\n    // 新增未保存区域\n    if (!this.dcCode) {\n        this.dtc ? this.setFillColor('yellow') : this.setFillColor('red');\n        this.setFillOpacity(0.6);\n        return;\n    }\n\n    // // 加盟商选中区域凸出高亮\n    // if (store.getters.isEqualId(this.dId) && this.unitExistence === 2) {\n    //     this.setFillColor('green');\n    //     this.setFillOpacity(0.4);\n    //     return;\n    // }\n    //\n    // // 相同加盟商单位级联高亮\n    // if (store.getters.isSameUnit(this.dcCode) && this.unitExistence === 2) {\n    //     this.setFillColor('green');\n    //     this.setFillOpacity(0.2);\n    //     return;\n    // }\n    //\n    // // 选中区域凸出高亮\n    // if (store.getters.isEqualId(this.dId)) {\n    //     this.setFillColor('red');\n    //     this.setFillOpacity(0.4);\n    //     return;\n    // }\n    //\n    // // 相同单位级联高亮\n    // if (store.getters.isSameUnit(this.dcCode)) {\n    //     this.setFillColor('red');\n    //     this.setFillOpacity(0.2);\n    //     return;\n    // }\n\n    // 还原样式\n    this.setFillColor('#000000');\n    this.setFillOpacity(0.08);\n};\n\n/**\n * 计算单位面积\n * @param newAcreage 该区域的新面积\n */\n// Polygon.prototype.unitArea = function () {\n//     // 选中区域 或 同单位\n//     if (store.getters.isEqualId(this.dId) || store.getters.isSameUnit(this.dcCode)) {\n//         let unitAreaBox = document.getElementById('unitAreaBox');\n//         if (!unitAreaBox) return;\n//         let acreage = parseFloat(this.acreage);\n//         let areas = parseFloat(unitAreaBox.innerHTML);\n//         if (!isNaN(acreage)) {\n//             if (!isNaN(areas)) {\n//                 acreage += areas;\n//             }\n//             unitAreaBox.innerHTML = acreage.toFixed(3);\n//         }\n//     }\n// };\n// /**\n//  * 更新单位面积\n//  */\n// Polygon.prototype.updateUnitArea = function () {\n//     // 选中区域 或 同单位\n//     if (store.getters.isEqualId(this.dId) || store.getters.isSameUnit(this.dcCode)) {\n//         // 原面积\n//         let acreage = parseFloat(this.acreage);\n//         if (isNaN(acreage)) {\n//             acreage = 0;\n//         }\n//\n//         // 新面积\n//         let newAcreage = AreaPath.acreage(this);\n//         // 自相交则不算面积\n//         if (ClipperLib.containKinks(GeoJSON.toGeoJSON(this.getPath()))) {\n//             newAcreage = '面积错误';\n//         }\n//         this.acreage = newAcreage;\n//         newAcreage = parseFloat(this.acreage);\n//         if (isNaN(newAcreage)) {\n//             newAcreage = 0;\n//         }\n//\n//         // 单位面积DOM\n//         let unitAreaBox = document.getElementById('unitAreaBox');\n//         if (!unitAreaBox) return;\n//         // 单位面积总数\n//         let areas = parseFloat(unitAreaBox.innerHTML);\n//         if (isNaN(areas)) {\n//             areas = 0;\n//         }\n//\n//         // 单位面积等于 0 则显示 面积错误\n//         let ua = (areas - (acreage - newAcreage)).toFixed(3);\n//         // unitAreaBox.innerHTML = ua * 1 !== 0 ? ua + 'km²' : '面积错误';\n//         unitAreaBox.innerHTML = !/^0.000$/.exec(ua) ? ua : '面积错误';\n//     }\n// };\n\n// 重写渲染函数\nPolygon.prototype.draw = function () {\n    BMap.Polygon.prototype.draw.call(this);\n\n    // 级联单位\n    this.cascadeUnit();\n};\n\n\n//# sourceURL=webpack:///./src/unit/layer/Polygon.js?");

/***/ })

}]);